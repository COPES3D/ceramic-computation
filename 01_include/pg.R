# helper functions for interacting with the database, all SQL code is located in this file, abstracted from other scripts

# the .config file contains the database authentication parameters, which need to be updated for each specific situation
source("01_include/.config")
library("RPostgreSQL")

# do the actual connect to the db that will be used in all subsequent scripts
pgconnect <- dbConnect("PostgreSQL",
                       host=pgHost,
                       port="5432",
                       dbname=pgDbname,
                       user=pgUser,
                       password=pgPassword)

# since we start from publications using the citation, the figureid of each drawing is used to work back to the database itemid
GetItemIdFromFigureId <- function(citation, figureid) {
  sqlstatement <- paste("select itemid from items.items_figures where citation='",
                        citation,"' and figureid='", figureid,"'", sep="")
  
  rs <- dbGetQuery(pgconnect,sqlstatement)

  return(rs$itemid)
}

# we can also sometimes work in the other direction, to find the figureid and citation, and other useful values, for the primary drawing
# this can be used to find the drawing on the filesystem
GetDrawingFromItemId <- function(itemid) {
  sqlstatement <- paste("select items.items_figures.*,items.items.siteid from items.items_figures ",
                          "join items.items on items.items.itemid=items.items_figures.itemid where ",
                          "items.items_figures.drawing=true and items.items_figures.primary=true and items.items_figures.itemid=",itemid,sep="")
  
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs)
}

# delete associated data from the item, usually so that it can then be repopulated
ClearCeramicData<-function(itemid) {
  sqlstatement <- paste("delete from items.ceramics_sections_rims_math where itemid=",
                        itemid, sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  print(rs)
  
  sqlstatement <- paste("delete from items.ceramics_sections where itemid=",
                        itemid, sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  print(rs)
  
  sqlstatement <- paste("delete from items.items_attributes_numeric where itemid=",
                        itemid, sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  print(rs)
}

# clear only the data that was generated by the math functions during comparison
ClearCeramicCompareData<-function(itemid, sectionid) {
  sqlstatement <- paste("delete from items.ceramics_sections_rims_math_normalization where itemid=",
                        itemid," and sectionid=",sectionid,sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  print(rs)
  
  sqlstatement <- paste("delete from items.ceramics_sections_rims_math_compare where itemid1=",
                        itemid," and sectionid1=",sectionid,sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  print(rs)
}

# this reformats an individual point for upload into the database table 
WriteFinalCoordinates<-function(itemid, coor, type) {
  coor$itemid<-itemid
  coor$sectionid<-1  # in theory, there could be multiple section drawings from the same vessel, ie from the same item
  coor$type<-type  # type indicates the type of section - such as rim or base
  # the db table is already properly formated
  dbWriteTable(pgconnect,c("items","ceramics_sections"), 
               coor[c("itemid","sectionid","pointid","type","X","Y")],
               append=TRUE,row.names=FALSE)
}

# write all of the results of the math functions on the section, including the three main functions: radius, tangent, and curvature
WriteMath<-function(itemid,radiusgraph,tangent,curvature) {
  # Curvature will likely be the smallest array since the end points are subsumed by averaging.
  # Thus the pointids and chord lengths can come out of that array, and the start and end pointids can be used to
  # limit the other arrays.
  pointid<-curvature[,"pointid"]
  chord_length<-curvature[,"chord"]
  startPoint<-curvature[,"pointid"][1]
  endPoint<-curvature[length(curvature[,"pointid"])]
  
  # Take the values for these two calculations based on the starting and ending point numbers.
  radius_cm<-radiusgraph[which(radiusgraph[,"pointid"]==startPoint):which(radiusgraph[,"pointid"]==endPoint),]$X
  tangent_rad<-tangent[which(tangent[,"pointid"]==startPoint):which(tangent[,"pointid"]==endPoint),][,"theta"]
  
  # Load these into a dataframe for writing to the db.  All values should be rounded for the db.  The sectionid is defaulted to 1.
  math<-as.data.frame(cbind(itemid,1,pointid,round(chord_length,3),radius_cm,round(tangent_rad,3),round(curvature[,"curve"],3)))
  dbWriteTable(pgconnect,c("items","ceramics_sections_rims_math"),math,append=TRUE,row.names=FALSE)
}

WriteCompare<-function(compareData) {
  dbWriteTable(pgconnect,c("items","ceramics_sections_rims_math_compare"),as.data.frame(compareData),append=TRUE,row.names=FALSE)
}

WriteNormalization<-function(normalData) {
  dbWriteTable(pgconnect,c("items","ceramics_sections_rims_math_normalization"),as.data.frame(normalData),append=TRUE,row.names=FALSE)
}

WriteProperties<-function(itemid,properties) {
  properties<-cbind(itemid,properties)
  dbWriteTable(pgconnect,c("items","items_attributes_numeric"),properties,append=TRUE,row.names=FALSE)
}

#the next set of functions perform read queries on the database, starting from reading all sections
GetCeramicSection <- function() {
  sqlstatement <- paste("select * from items.ceramics_sections", sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs)
}

GetSpecificCeramicSection<-function(itemid, sectionid) {
  sqlstatement <- paste("select * from items.ceramics_sections where itemid=",itemid," and sectionid=",sectionid, sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs)
}

GetCeramicSectionRimRadiusMath <- function() {
  sqlstatement <- "SELECT * FROM items.ceramics_sections_rims_math WHERE itemid IN (SELECT cs.itemid FROM items.ceramics_sections cs WHERE cs.type='rim with radius'  GROUP BY cs.itemid) ORDER BY itemid, sectionid, pointid"
}

GetCeramicSectionRimMath <- function() {
  sqlstatement <- paste("select * from items.ceramics_sections_rims_math order by itemid,sectionid,pointid", sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs)
}

# a table in the database enables the disabling of items from the calculations
GetCeramicSectionRimMathWithoutDisabled <- function(startAt) {
  sqlstatement <- paste("select * from items.ceramics_sections_rims_math WHERE itemid NOT IN (SELECT itemid FROM items.items_disabled) AND itemid<",startAt," order by itemid DESC,sectionid,pointid", sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs)
}

GetCeramicSectionRimType <- function(itemid) {
  sqlstatement <- paste("select itemid, type from items.ceramics_sections where itemid=",itemid," group by itemid, type", sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs["type"])
}

GetCeramicSectionRimMathInProcess <- function() {
  sqlstatement <- paste("select * from items.view_ceramics_sections_rims_math_in_process", sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs)
}

GetItemFigures <- function() {
  sqlstatement <- paste("select * from items.items_figures where citation<>'photo' and height is null order by itemid", sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs)
}

GetProcedureProperty <- function(property) {
  sqlstatement <- paste("select * from options.procedure_properties where property='",property,"'", sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs['value'])
}

WriteFigureProperties <- function(itemid,citation,figureid,height,width,dpi)
{
  sqlstatement <- paste("UPDATE items.items_figures SET height=",height,", width=",width,", dots_per_inch=",dpi," WHERE itemid=",itemid," AND citation='",citation,"' AND figureid='",figureid,"'", sep="")
  return(dbGetQuery(pgconnect,sqlstatement))
}

GetItemsInProcess <- function() {
  sqlstatement <- paste("select * from items.view_items_in_process", sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  return(rs)
}


GetCeramicSectionList <- function() {
  sqlstatement <- paste("select distinct itemid, sectionid from items.ceramics_sections order by itemid, sectionid")
  return(dbGetQuery(pgconnect,sqlstatement))
}

# function specific to the David French 1969, Anatolia Survey publication of ceramics
GetFrenchDiameter <- function(itemid)
{
  sqlstatement <- paste("select \"Rim diameter meters\" from publications.french_finds where itemid=",itemid, sep="")
  rs <- dbGetQuery(pgconnect,sqlstatement)
  
  if (nrow(rs)>0)
  {
    return(paste("rad:",rs[1,]*100/2))
  } else {
    return("No dia")
  }
  
}

# experimental code for starting to work between RGB and Munsell colors
GetMunsellName <- function(hue,lightness_value,chroma) {
  sqlstatement <- paste("select description from options.munsell_colors where hue='",hue[1,],"' and lightness_value=",lightness_value," and chroma=",chroma,sep="")
  return(dbGetQuery(pgconnect,sqlstatement))
}

GetMunsellByHue <- function(hue)
{
  sqlstatement <- paste("select * from options.munsell_colors where hue='",hue,"'",sep="")
  return(dbGetQuery(pgconnect,sqlstatement))
}

GetMunsell2RGB <- function(hue,lightness_value,chroma)
{
  sqlstatement <- paste("select description from options.munsell_colors where hue='",hue,"' and lightness_value=",lightness_value," and chroma=",chroma,sep="")
  return(dbGetQuery(pgconnect,sqlstatement))
}

GetMunsellRGBTable <- function()
{
  sqlstatement <- "select * from options.munsell_colors where red is not null"
  return(dbGetQuery(pgconnect,sqlstatement))
}

InsertMunsellExteriorSurface <- function(itemid, hue, lightness_value, chroma)
{
  sqlstatement <- paste("insert into items.items_attributes_munsell",
                          "(itemid, reading_location, hue, lightness_value, chroma) ",
                          "values(",itemid,",'Exterior Surface','",hue,"',",lightness_value,",",chroma,")", sep="")
  dbSendQuery(pgconnect,sqlstatement)
}
